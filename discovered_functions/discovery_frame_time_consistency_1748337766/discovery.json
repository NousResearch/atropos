{
  "discovery_id": "discovery_frame_time_consistency_1748337766",
  "domain": "frame_time_consistency",
  "timestamp": "2025-05-27T02:22:46.510597",
  "function_code": "import numpy as np\n\ndef vr_optimization_function(gpu_util, vram_usage, cpu_util, scene_complexity, duration, gpu_type):\n    \"\"\"\n    Optimizes VR performance for frame time consistency and comfort.\n\n    Args:\n        gpu_util (float): GPU utilization percentage (0-100).\n        vram_usage (float): VRAM usage in GB.\n        cpu_util (float): CPU utilization percentage (0-100).\n        scene_complexity (float): Scene complexity score (higher is more complex).\n        duration (float): Frame time in milliseconds.\n        gpu_type (float): GPU type (numerical representation, higher is better).\n\n\n    Returns:\n        float: Optimized performance score between 0 and 1 (higher is better). \n               Returns -1 if input validation fails.\n\n    Raises:\n        TypeError: If any input is not a number.\n        ValueError: If any input is outside the acceptable range.\n\n    \"\"\"\n    # Input validation\n    if not all(isinstance(x, (int, float)) for x in [gpu_util, vram_usage, cpu_util, scene_complexity, duration, gpu_type]):\n        raise TypeError(\"All inputs must be numbers.\")\n\n    if not (0 <= gpu_util <= 100 and 0 <= cpu_util <= 100 and duration > 0 and scene_complexity >=0 and vram_usage >=0 and gpu_type > 0):\n        raise ValueError(\"Invalid input range. Check GPU utilization, CPU utilization, duration, scene complexity, VRAM usage and GPU type.\")\n\n\n    # Feature normalization (min-max scaling)\n    gpu_util_norm = gpu_util / 100.0\n    cpu_util_norm = cpu_util / 100.0\n    # Assuming a reasonable upper bound for VRAM usage (adjust as needed)\n    vram_usage_norm = min(vram_usage / 16.0, 1.0) #Normalizes to a max of 16GB\n    # scene complexity normalization depends on the expected range, adjust accordingly.\n    scene_complexity_norm = min(scene_complexity / 10.0,1.0) #Normalized to a max complexity of 10\n    # Assuming a target frame time of 16ms.  Adjust as needed for your target.\n    duration_norm = 1.0 / (1 + (duration / 16.0))  #Inversely proportional to frame time.\n\n\n    # Optimization logic (weighted average focusing on frame time consistency and resource utilization)\n\n    #Weights adjusted based on importance for VR comfort. Frame time is most crucial.\n    weight_duration = 0.5\n    weight_gpu = 0.2\n    weight_cpu = 0.2\n    weight_vram = 0.05\n    weight_scene = 0.05\n\n\n    optimized_score = (weight_duration * duration_norm + \n                       weight_gpu * (1 - gpu_util_norm) +  #Lower GPU usage is better\n                       weight_cpu * (1 - cpu_util_norm) + #Lower CPU usage is better\n                       weight_vram * (1 - vram_usage_norm) + #Lower VRAM usage is better\n                       weight_scene * (1/(1+scene_complexity_norm)) #Lower scene complexity is better\n                      )\n\n    # Ensure score is within [0, 1] range.\n    optimized_score = np.clip(optimized_score, 0, 1)\n\n\n    return optimized_score",
  "fitness_score": 0.9,
  "discovery_method": "funsearch",
  "generations_run": 50,
  "population_size": 30,
  "discovery_time": "2025-05-27T02:22:46.509815"
}
