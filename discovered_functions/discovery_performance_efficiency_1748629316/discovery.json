{
  "discovery_id": "discovery_performance_efficiency_1748629316",
  "domain": "performance_efficiency",
  "timestamp": "2025-05-30T11:21:56.443052",
  "function_code": "import numpy as np\n\ndef vr_optimization_function(gpu_util, vram_usage, cpu_util, scene_complexity, duration, gpu_type):\n    \"\"\"\n    Optimizes VR performance focusing on GPU utilization.\n\n    Args:\n        gpu_util (float): GPU utilization percentage (0-100).\n        vram_usage (float): VRAM usage in GB.\n        cpu_util (float): CPU utilization percentage (0-100).\n        scene_complexity (float): Scene complexity score (higher is more complex).\n        duration (float): Frame time in seconds.\n        gpu_type (float): GPU type (numerical representation, e.g., 1 for GTX 1660, 2 for RTX 3070, etc.).\n\n    Returns:\n        float: Optimized performance score between 0 and 1 (higher is better). Returns -1 if input is invalid.\n\n    Raises:\n        TypeError: if any input is not a number.\n        ValueError: if any input is outside the expected range.\n\n    \"\"\"\n\n    # Input validation\n    if not all(isinstance(x, (int, float)) for x in [gpu_util, vram_usage, cpu_util, scene_complexity, duration, gpu_type]):\n        raise TypeError(\"All inputs must be numbers.\")\n    if not 0 <= gpu_util <= 100:\n        raise ValueError(\"GPU utilization must be between 0 and 100.\")\n    if not vram_usage >= 0:  #VRAM usage can be arbitrarily high.\n        raise ValueError(\"VRAM usage must be non-negative.\")\n    if not 0 <= cpu_util <= 100:\n        raise ValueError(\"CPU utilization must be between 0 and 100.\")\n    if not scene_complexity >= 0: #Scene complexity can be arbitrarily high\n        raise ValueError(\"Scene complexity must be non-negative.\")\n    if not duration > 0:\n        raise ValueError(\"Duration must be positive.\")\n    if not gpu_type > 0: #GPU type should be a positive identifier.\n        raise ValueError(\"GPU type must be positive.\")\n\n\n    # Feature normalization (min-max scaling)\n    gpu_util_norm = gpu_util / 100.0\n    cpu_util_norm = cpu_util / 100.0\n    #Assuming vram_usage is in GB, a reasonable upper bound needs to be established for normalization.  16GB is used here as an example. Adjust as needed.\n    vram_usage_norm = np.clip(vram_usage / 16.0, 0,1) #Clip to prevent values greater than 1.\n    #Assuming scene complexity and duration are already somewhat normalized, no further scaling might be needed. Adjust as needed depending on your data.\n\n\n    # Optimization logic (weighted average focusing on GPU utilization)\n    # Weights are adjusted to prioritize GPU utilization.  Adjust weights as needed based on priorities.\n    gpu_weight = 0.6\n    vram_weight = 0.1\n    cpu_weight = 0.1\n    scene_weight = 0.1\n    duration_weight = 0.1  #Lower weight because a slightly longer frame time is less critical than high GPU utilization.\n\n    optimized_score = (gpu_weight * gpu_util_norm) - (vram_weight * vram_usage_norm) - (cpu_weight * cpu_util_norm) - (scene_weight * scene_complexity) - (duration_weight * duration)\n\n\n    #Handle potential negative scores.  This adjustment prevents negative scores. Adjust as needed.\n    optimized_score = max(0, optimized_score)\n\n    #Ensure score is within 0-1 range\n    optimized_score = np.clip(optimized_score, 0,1)\n\n    return optimized_score",
  "fitness_score": 0.9,
  "discovery_method": "funsearch",
  "generations_run": 50,
  "population_size": 30,
  "discovery_time": "2025-05-30T11:21:56.442327"
}