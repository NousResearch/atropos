{
  "discovery_id": "discovery_performance_efficiency_1748341214",
  "domain": "performance_efficiency",
  "timestamp": "2025-05-27T03:20:14.753164",
  "function_code": "import numpy as np\n\ndef vr_optimization_function(gpu_util, vram_usage, cpu_util, scene_complexity, duration, gpu_type):\n    \"\"\"\n    Optimizes VR performance score based on GPU utilization.\n\n    Args:\n        gpu_util (float): GPU utilization percentage (0-100).\n        vram_usage (float): VRAM usage in GB.\n        cpu_util (float): CPU utilization percentage (0-100).\n        scene_complexity (float): Scene complexity score (higher is more complex).\n        duration (float): Frame rendering duration in seconds.\n        gpu_type (float): GPU type (higher is better).  Assume a numerical representation.\n\n    Returns:\n        float: Optimized performance score between 0 and 1 (higher is better). \n               Returns -1 if input validation fails.\n\n    Raises:\n        TypeError: if any input is not a number.\n        ValueError: if any input is out of range.\n\n    \"\"\"\n\n    # Input validation\n    if not all(isinstance(i, (int, float)) for i in [gpu_util, vram_usage, cpu_util, scene_complexity, duration, gpu_type]):\n        raise TypeError(\"All inputs must be numbers.\")\n    if not (0 <= gpu_util <= 100 and 0 <= cpu_util <= 100 and scene_complexity >=0 and duration > 0 and gpu_type > 0):  # Allow vram to be arbitrarily large\n        raise ValueError(\"Invalid input range.  Check GPU utilization, CPU utilization, Scene Complexity and Duration.\")\n\n\n    # Feature normalization (min-max scaling)\n    gpu_util_norm = gpu_util / 100.0  # Normalize to 0-1 range\n    cpu_util_norm = cpu_util / 100.0\n    # Assuming higher scene complexity reduces performance, hence 1 - scene_complexity\n    scene_complexity_norm = 1.0 / (1 + scene_complexity) #Inverse scaling to penalize high complexity.\n    #duration is inversely proportional to performance\n    duration_norm = 1 / (1 + duration)\n\n    #Consider GPU type as a weight\n    gpu_type_weight = gpu_type / (gpu_type + 5) #example weighting scheme. Adjust as needed.\n\n\n    #Optimization Logic: prioritize GPU utilization, then minimize VRAM and CPU usage, duration, and maximize GPU type\n    #Weights can be adjusted based on priorities.\n    performance_score = (0.5 * gpu_util_norm + \n                         0.15 * (1 - vram_usage / 20.0) + #Assumes a reasonable maximum VRAM of 20GB. Adjust as needed.\n                         0.15 * (1 - cpu_util_norm) +\n                         0.1 * duration_norm +\n                         0.1 * scene_complexity_norm +\n                         0.1 * gpu_type_weight)\n\n\n    #Clip the score between 0 and 1\n    return np.clip(performance_score, 0, 1)",
  "fitness_score": 0.9,
  "discovery_method": "funsearch",
  "generations_run": 50,
  "population_size": 30,
  "discovery_time": "2025-05-27T03:20:14.751150"
}
