{
  "discovery_id": "discovery_frame_time_consistency_1748337296",
  "domain": "frame_time_consistency",
  "timestamp": "2025-05-27T02:14:56.473182",
  "function_code": "import numpy as np\n\ndef vr_optimization_function(gpu_util, vram_usage, cpu_util, scene_complexity, duration, gpu_type):\n    \"\"\"\n    Optimizes VR performance score based on input features.  Higher score indicates better frame time consistency.\n\n    Args:\n        gpu_util (float): GPU utilization percentage (0-100).\n        vram_usage (float): VRAM usage in GB.\n        cpu_util (float): CPU utilization percentage (0-100).\n        scene_complexity (float): Scene complexity score (higher is more complex).\n        duration (float): Frame time duration in seconds.\n        gpu_type (float): GPU type (numeric representation, e.g., 2.0 for RTX 2080,  higher is better).\n\n\n    Returns:\n        float: Optimized performance score between 0 and 1 (inclusive). Returns -1 if input is invalid.\n\n    Raises:\n        TypeError: if input types are not numeric.\n        ValueError: if input values are out of range.\n\n    \"\"\"\n\n    # Input validation\n    if not all(isinstance(x, (int, float)) for x in [gpu_util, vram_usage, cpu_util, scene_complexity, duration, gpu_type]):\n        raise TypeError(\"All inputs must be numeric.\")\n\n    if not (0 <= gpu_util <= 100 and 0 <= cpu_util <= 100 and vram_usage >= 0 and scene_complexity >= 0 and duration > 0 and gpu_type > 0):\n        raise ValueError(\"Invalid input range. Check values for gpu_util, cpu_util, vram_usage, scene_complexity, duration and gpu_type.\")\n\n\n    # Feature normalization (min-max scaling)\n    gpu_util_norm = gpu_util / 100.0  #Scale GPU utilization to 0-1\n    cpu_util_norm = cpu_util / 100.0  #Scale CPU utilization to 0-1\n\n    # Considering that higher scene complexity and VRAM usage can affect performance negatively, we invert their normalization.\n    # A lower normalized value for these indicates better performance in this context.\n    vram_usage_norm = 1.0 / (1 + vram_usage) #inverse scaling of VRAM to handle large values and avoid division by zero\n\n    #We assume there is an upper limit for scene complexity that would result in poor performance\n    scene_complexity_norm = 1.0 / (1 + scene_complexity) # inverse scaling\n\n    #Duration is inversely proportional to performance; shorter is better\n    duration_norm = 1.0 / (1 + duration) # inverse scaling\n\n    #GPU type is assumed to be already scaled relative to a baseline\n    gpu_type_norm = gpu_type / 10.0 # Adjust the divisor (10 here) based on your expected range of gpu_type values\n\n    # Optimization logic (weighted average, emphasizing duration and GPU type for VR comfort)\n    weights = np.array([0.1, 0.1, 0.1, 0.2, 0.3, 0.2]) # Assign weights based on importance.  Duration and GPU type are given higher weight\n\n    normalized_features = np.array([gpu_util_norm, vram_usage_norm, cpu_util_norm, scene_complexity_norm, duration_norm, gpu_type_norm])\n\n    performance_score = np.dot(normalized_features, weights)\n\n\n    # Ensure score is within the 0-1 range\n    return np.clip(performance_score, 0, 1)",
  "fitness_score": 0.9,
  "discovery_method": "funsearch",
  "generations_run": 50,
  "population_size": 30,
  "discovery_time": "2025-05-27T02:14:56.472309"
}
