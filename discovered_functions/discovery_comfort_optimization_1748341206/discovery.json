{
  "discovery_id": "discovery_comfort_optimization_1748341206",
  "domain": "comfort_optimization",
  "timestamp": "2025-05-27T03:20:06.428220",
  "function_code": "import numpy as np\n\ndef vr_optimization_function(gpu_util, vram_usage, cpu_util, scene_complexity, duration, gpu_type):\n    \"\"\"\n    Optimizes VR performance to maximize comfort score.\n\n    Args:\n        gpu_util (float): GPU utilization percentage (0-100).\n        vram_usage (float): VRAM usage in GB.\n        cpu_util (float): CPU utilization percentage (0-100).\n        scene_complexity (float): Scene complexity score (higher is more complex).\n        duration (float): Duration of VR experience in seconds.\n        gpu_type (float): GPU type (e.g., 2.0 for RTX 2080, 3.5 for RTX 3080).\n\n    Returns:\n        float: Optimized VR comfort score between 0 and 1 (higher is better). \n               Returns -1 if input is invalid.\n\n    Raises:\n        TypeError: if any input is not a number.\n        ValueError: if any input is outside the expected range.\n\n    \"\"\"\n\n    # Input validation\n    if not all(isinstance(x, (int, float)) for x in [gpu_util, vram_usage, cpu_util, scene_complexity, duration, gpu_type]):\n        raise TypeError(\"All inputs must be numbers.\")\n\n    if not (0 <= gpu_util <= 100 and 0 <= cpu_util <= 100 and scene_complexity >=0 and duration > 0 and gpu_type > 0):\n        raise ValueError(\"Invalid input range.\")\n\n    # Feature normalization (min-max scaling)\n    gpu_util_norm = gpu_util / 100.0  \n    cpu_util_norm = cpu_util / 100.0\n    # Assuming VRAM usage is capped at 24GB for this example. Adjust as needed based on your data\n    vram_usage_norm = vram_usage / 24.0\n\n\n    #Optimization Logic (weighted average with penalties for high resource usage and complexity)\n\n    #Weights are adjusted based on importance. Experiment to find optimal values for your data.\n    gpu_weight = 0.3\n    cpu_weight = 0.2\n    vram_weight = 0.2\n    complexity_weight = 0.2\n    gpu_type_weight = 0.1\n\n    #Penalties are applied to high resource usage and complexity, reducing the comfort score.\n    gpu_penalty = 1 - np.exp(-(gpu_util_norm - 0.8)**2) #Penalty for high GPU usage, centered around 80%\n    cpu_penalty = 1 - np.exp(-(cpu_util_norm - 0.7)**2) #Penalty for high CPU usage, centered around 70%\n    vram_penalty = 1 - np.exp(-(vram_usage_norm - 0.6)**2) #Penalty for high VRAM usage, centered around 6GB\n    complexity_penalty = 1 - np.exp(-(scene_complexity)**2) #Penalty for high scene complexity\n\n\n    comfort_score = (gpu_weight * (1-gpu_penalty) * (1-gpu_util_norm) + \n                    cpu_weight * (1-cpu_penalty) * (1-cpu_util_norm) + \n                    vram_weight * (1-vram_penalty) * (1-vram_usage_norm) +\n                    complexity_weight *(1-complexity_penalty)*(1/(scene_complexity+1)) + \n                    gpu_type_weight * (gpu_type/5.0)) #Reward for better GPU type\n\n\n    #Ensure the score is within 0-1 range\n    comfort_score = max(0, min(1, comfort_score))\n    return comfort_score",
  "fitness_score": 0.9,
  "discovery_method": "funsearch",
  "generations_run": 50,
  "population_size": 30,
  "discovery_time": "2025-05-27T03:20:06.427545"
}
