{
  "discovery_id": "discovery_comfort_optimization_1748625979",
  "domain": "comfort_optimization",
  "timestamp": "2025-05-30T10:26:19.702357",
  "function_code": "import numpy as np\n\ndef vr_optimization_function(gpu_util, vram_usage, cpu_util, scene_complexity, duration, gpu_type):\n    \"\"\"\n    Optimizes VR performance for maximum comfort score.\n\n    Args:\n        gpu_util (float): GPU utilization (%).\n        vram_usage (float): VRAM usage (GB).\n        cpu_util (float): CPU utilization (%).\n        scene_complexity (float): Scene complexity score (higher is more complex).\n        duration (float): Duration of the VR experience (seconds).\n        gpu_type (float): GPU type (numerical representation, e.g., 1 for GTX 1660, 2 for RTX 3070, etc.).\n\n\n    Returns:\n        float: Optimized VR comfort score between 0 and 1 (inclusive). Returns -1 if input is invalid.\n\n    Raises:\n        TypeError: if any input is not a number.\n        ValueError: if any input is outside the acceptable range.\n\n    \"\"\"\n\n    # Input validation\n    if not all(isinstance(x, (int, float)) for x in [gpu_util, vram_usage, cpu_util, scene_complexity, duration, gpu_type]):\n        raise TypeError(\"All inputs must be numbers.\")\n\n    if not (0 <= gpu_util <= 100 and 0 <= cpu_util <= 100 and vram_usage >= 0 and scene_complexity >= 0 and duration > 0 and gpu_type > 0):\n        raise ValueError(\"Invalid input range. Check your input values.\")\n\n\n    # Feature normalization (min-max scaling)\n    gpu_util_norm = gpu_util / 100  #Scale GPU and CPU utilization to 0-1 range.\n    cpu_util_norm = cpu_util / 100\n\n    #  Assume reasonable max values for other features based on typical VR usage. Adjust these values if needed based on your specific dataset and hardware.\n    max_vram = 24  #GB\n    max_scene_complexity = 5\n    max_duration = 10 # minutes, converted to seconds\n\n    vram_usage_norm = vram_usage / max_vram\n    scene_complexity_norm = scene_complexity / max_scene_complexity\n    duration_norm = duration / (max_duration * 60) #scaling duration to be within 0-1.\n\n\n    #Mathematical optimization logic (weighted average with penalties)\n    #Weights are assigned based on domain knowledge \u2013 adjust them based on your needs\n    weight_gpu = 0.25\n    weight_cpu = 0.15\n    weight_vram = 0.2\n    weight_scene = 0.2\n    weight_duration = 0.1\n    weight_gpu_type = 0.1 #Higher GPU type should ideally improve score.\n\n    #Penalties for high utilization.  These penalty functions are examples;  you may need to experiment with different functions\n    gpu_penalty = 1 - np.exp(-gpu_util_norm**2)  #Increasing penalty as utilization rises exponentially.\n    cpu_penalty = 1 - np.exp(-cpu_util_norm**2)\n    vram_penalty = vram_usage_norm **2 #Quadratic penalty for high VRAM usage\n\n    # Calculate the weighted score \u2013 a higher score indicates better performance and comfort\n    comfort_score = (1 - gpu_penalty) * weight_gpu + \\\n                    (1 - cpu_penalty) * weight_cpu + \\\n                    (1- vram_penalty) * weight_vram + \\\n                    (1 - scene_complexity_norm) * weight_scene + \\\n                    (1 - duration_norm) * weight_duration + \\\n                    (gpu_type/10) * weight_gpu_type #Scaling gpu_type to be within a reasonable range\n\n    #Ensure the score is within the 0-1 range.\n    comfort_score = max(0, min(1, comfort_score))\n\n    return comfort_score",
  "fitness_score": 0.9,
  "discovery_method": "funsearch",
  "generations_run": 50,
  "population_size": 30,
  "discovery_time": "2025-05-30T10:26:19.701702"
}
