{
  "discovery_id": "discovery_frame_time_consistency_1748629300",
  "domain": "frame_time_consistency",
  "timestamp": "2025-05-30T11:21:40.041188",
  "function_code": "import numpy as np\n\ndef vr_optimization_function(gpu_util, vram_usage, cpu_util, scene_complexity, duration, gpu_type):\n    \"\"\"\n    Optimizes VR performance for frame time consistency and comfort.\n\n    Args:\n        gpu_util (float): GPU utilization percentage (0-100).\n        vram_usage (float): VRAM usage in GB.\n        cpu_util (float): CPU utilization percentage (0-100).\n        scene_complexity (float): Scene complexity score (higher is more complex).\n        duration (float): Frame time in seconds.\n        gpu_type (float): GPU type (e.g., 1.0, 2.0, 3.0 representing different tiers).\n\n    Returns:\n        float: Optimized performance score between 0 and 1 (higher is better). \n               Returns -1 if input validation fails.\n\n    Raises:\n        TypeError: if input data types are not numeric.\n        ValueError: if input values are out of range.\n    \"\"\"\n\n    # Input validation\n    if not all(isinstance(i, (int, float)) for i in [gpu_util, vram_usage, cpu_util, scene_complexity, duration, gpu_type]):\n        raise TypeError(\"All inputs must be numeric.\")\n\n    if not (0 <= gpu_util <= 100 and 0 <= cpu_util <= 100 and vram_usage >= 0 and scene_complexity >= 0 and duration > 0 and gpu_type > 0):\n        raise ValueError(\"Input values are out of range.\")\n\n\n    # Feature normalization (min-max scaling) to prevent features with larger magnitudes from dominating.\n    gpu_util_norm = gpu_util / 100.0  \n    cpu_util_norm = cpu_util / 100.0\n    vram_usage_norm = vram_usage / 16 #Assuming a maximum of 16GB VRAM as a reasonable upper bound. Adjust as needed.\n    scene_complexity_norm = scene_complexity / 10 # Assuming a max complexity score of 10, adjust as needed.\n    duration_norm = 1 / (duration + 0.001) #Reciprocal to reward shorter frame times. Added a small value to prevent division by zero.\n\n\n    # Optimization logic: Weighted average focusing on frame time and resource utilization.\n    # Weights are adjusted based on importance; Frame time consistency is prioritized.\n    weights = np.array([0.4, 0.2, 0.2, 0.1, 0.1])  #Weights for duration, gpu_util, cpu_util, vram, scene complexity respectively\n\n    normalized_features = np.array([duration_norm, gpu_util_norm, cpu_util_norm, vram_usage_norm, scene_complexity_norm])\n    \n    #GPU type influence: penalize lower end cards more for high utilization\n    gpu_type_penalty = 1 - (gpu_type/5) #Assumes a maximum GPU type of 5. Adjust accordingly.\n    gpu_type_penalty = max(0, min(1,gpu_type_penalty)) #Clamp between 0 and 1\n\n    optimized_score = np.dot(weights, 1-normalized_features) * (1-gpu_type_penalty)\n\n\n    #Ensure score is within [0,1]\n    return max(0,min(1, optimized_score))",
  "fitness_score": 0.9,
  "discovery_method": "funsearch",
  "generations_run": 50,
  "population_size": 30,
  "discovery_time": "2025-05-30T11:21:40.040533"
}