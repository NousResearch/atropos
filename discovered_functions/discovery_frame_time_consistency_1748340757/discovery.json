{
  "discovery_id": "discovery_frame_time_consistency_1748340757",
  "domain": "frame_time_consistency",
  "timestamp": "2025-05-27T03:12:37.424252",
  "function_code": "import numpy as np\n\ndef vr_optimization_function(gpu_util, vram_usage, cpu_util, scene_complexity, duration, gpu_type):\n    \"\"\"\n    Optimizes VR performance for frame time consistency to enhance user comfort.\n\n    Args:\n        gpu_util (float): GPU utilization percentage (0-100).\n        vram_usage (float): VRAM usage in GB.\n        cpu_util (float): CPU utilization percentage (0-100).\n        scene_complexity (float): Scene complexity score (higher is more complex).\n        duration (float): Frame time in seconds.\n        gpu_type (float): GPU type (e.g., 2.0 for RTX 2080, 3.5 for RTX 3080).  Higher is better.\n\n\n    Returns:\n        float: Optimized performance score between 0 and 1 (inclusive). Higher score indicates better performance and smoother VR experience. Returns -1 if input is invalid.\n\n    Raises:\n        TypeError: if input types are not numerical.\n        ValueError: if input values are out of range.\n\n    \"\"\"\n    # Input validation\n    if not all(isinstance(x, (int, float)) for x in [gpu_util, vram_usage, cpu_util, scene_complexity, duration, gpu_type]):\n        raise TypeError(\"All inputs must be numerical.\")\n    if not (0 <= gpu_util <= 100 and 0 <= cpu_util <= 100 and vram_usage >= 0 and scene_complexity >= 0 and duration > 0 and gpu_type > 0):\n        raise ValueError(\"Invalid input range. Check values for gpu_util, cpu_util, vram_usage, scene_complexity, duration, and gpu_type.\")\n\n\n    # Feature normalization (min-max scaling)\n    gpu_util_norm = gpu_util / 100  # Normalize to 0-1\n    cpu_util_norm = cpu_util / 100  # Normalize to 0-1\n\n    #Avoid division by zero if scene complexity or duration are 0.  Add a small constant to prevent this.\n    scene_complexity_norm = scene_complexity / (scene_complexity + 1e-9) #Normalize and prevent divide by zero\n    duration_norm = 1 / (duration + 1e-9) #Inverse duration: shorter frame times are better\n\n\n    #Weighting factors based on importance (adjust as needed)\n    weight_gpu = 0.3\n    weight_cpu = 0.2\n    weight_vram = 0.1\n    weight_scene = 0.2\n    weight_duration = 0.2\n    weight_gpu_type = 0.1\n\n\n    # Optimization logic (weighted average with emphasis on frame time and resource efficiency)\n    performance_score = (weight_gpu * (1 - gpu_util_norm) +  # Lower GPU usage is better\n                        weight_cpu * (1 - cpu_util_norm) +  # Lower CPU usage is better\n                        weight_vram * (1 - min(vram_usage / 16, 1)) + #VRAM usage capped at 16GB, normalized to 0-1. Lower is better\n                        weight_scene * (1 / (scene_complexity_norm + 1e-9)) + #Lower scene complexity is better. Avoid division by zero\n                        weight_duration * duration_norm +          #Shorter frame times are better.\n                        weight_gpu_type * (gpu_type / 5)) #GPU type score normalized by max type\n\n    #Ensure the score is within 0-1\n    performance_score = np.clip(performance_score, 0, 1)\n\n    return performance_score",
  "fitness_score": 0.9,
  "discovery_method": "funsearch",
  "generations_run": 50,
  "population_size": 30,
  "discovery_time": "2025-05-27T03:12:37.422916"
}