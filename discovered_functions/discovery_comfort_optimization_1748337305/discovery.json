{
  "discovery_id": "discovery_comfort_optimization_1748337305",
  "domain": "comfort_optimization",
  "timestamp": "2025-05-27T02:15:05.946543",
  "function_code": "import numpy as np\n\ndef vr_optimization_function(gpu_util, vram_usage, cpu_util, scene_complexity, duration, gpu_type):\n    \"\"\"\n    Optimizes VR performance for maximum comfort score.\n\n    Args:\n        gpu_util (float): GPU utilization percentage (0-100).\n        vram_usage (float): VRAM usage in GB.\n        cpu_util (float): CPU utilization percentage (0-100).\n        scene_complexity (float): Scene complexity score (higher is more complex).\n        duration (float): Duration of VR experience in seconds.\n        gpu_type (float): GPU type (numerical representation, e.g., 2.0 for RTX 2080).\n\n\n    Returns:\n        float: Optimized performance score between 0 and 1 (higher is better). \n               Returns None if input is invalid.\n    \"\"\"\n\n    # Input validation\n    if not all(isinstance(x, (int, float)) for x in [gpu_util, vram_usage, cpu_util, scene_complexity, duration, gpu_type]):\n        print(\"Error: All inputs must be numeric.\")\n        return None\n    if not 0 <= gpu_util <= 100 or not 0 <= cpu_util <= 100:\n        print(\"Error: GPU and CPU utilization must be between 0 and 100.\")\n        return None\n    if vram_usage < 0 or scene_complexity < 0 or duration < 0 or gpu_type < 0:\n        print(\"Error: VRAM usage, scene complexity, duration and GPU type cannot be negative.\")\n        return None\n\n\n    # Feature normalization (min-max scaling)\n    gpu_util_norm = gpu_util / 100  #Normalize to 0-1 range\n    cpu_util_norm = cpu_util / 100  #Normalize to 0-1 range\n\n    #Define weights based on importance (adjust as needed based on domain expertise)\n    weights = {\n        'gpu_util': 0.3,  #higher weight for GPU utilization\n        'vram_usage': 0.2,\n        'cpu_util': 0.2,\n        'scene_complexity': 0.1, #Lower weight to avoid penalizing complex scenes too heavily\n        'duration': 0.1,      #Lower weight for duration\n        'gpu_type': 0.1      # Moderate weight for GPU type\n    }\n\n    # Optimization logic (weighted average with penalties for high resource usage)\n\n    # Penalty functions for high resource usage.  These are examples, adjust as needed.\n    gpu_penalty = np.exp(gpu_util_norm - 0.8) -1 if gpu_util_norm > 0.8 else 0  #Increased penalty above 80%\n    cpu_penalty = np.exp(cpu_util_norm - 0.7) -1 if cpu_util_norm > 0.7 else 0 #Increased penalty above 70%\n    vram_penalty =  np.exp(vram_usage/10) -1 if vram_usage > 6 else 0 #Increased penalty above 6GB\n\n\n    weighted_score = (weights['gpu_util'] * (1 - gpu_penalty) * (1- gpu_util_norm) + #Prioritize lower GPU usage\n                      weights['cpu_util'] * (1 - cpu_penalty) * (1 - cpu_util_norm) + #Prioritize lower CPU usage\n                      weights['vram_usage'] * (1 - vram_penalty) * (1 - (vram_usage/10)) + #Prioritize lower VRAM usage\n                      weights['scene_complexity'] * (1 / (1 + scene_complexity)) + #Inverse relationship with complexity\n                      weights['duration'] * (1 / (1 + duration)) + #Inverse relationship with duration\n                      weights['gpu_type'] * (gpu_type / 4) ) # Higher GPU type means better performance\n\n    # Ensure score is within the range [0, 1]\n    optimized_score = np.clip(weighted_score, 0, 1)\n\n    return optimized_score",
  "fitness_score": 0.9,
  "discovery_method": "funsearch",
  "generations_run": 50,
  "population_size": 30,
  "discovery_time": "2025-05-27T02:15:05.945019"
}
