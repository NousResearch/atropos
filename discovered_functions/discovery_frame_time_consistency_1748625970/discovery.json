{
  "discovery_id": "discovery_frame_time_consistency_1748625970",
  "domain": "frame_time_consistency",
  "timestamp": "2025-05-30T10:26:10.513071",
  "function_code": "import numpy as np\n\ndef vr_optimization_function(gpu_util, vram_usage, cpu_util, scene_complexity, duration, gpu_type):\n    \"\"\"\n    Optimizes VR performance for frame time consistency and comfort.\n\n    Args:\n        gpu_util (float): GPU utilization percentage (0-100).\n        vram_usage (float): VRAM usage in GB.\n        cpu_util (float): CPU utilization percentage (0-100).\n        scene_complexity (float): Scene complexity score (higher is more complex).\n        duration (float): Frame time in seconds.\n        gpu_type (float): GPU type (numeric representation, e.g., 1 for RTX 3080, 2 for RTX 4090).\n\n\n    Returns:\n        float: Optimized performance score between 0 and 1 (higher is better). \n               Returns -1 if input validation fails.\n\n    Raises:\n        TypeError: If any input is not a number.\n        ValueError: If any input is out of range.\n\n    \"\"\"\n\n    # Input validation\n    if not all(isinstance(x, (int, float)) for x in [gpu_util, vram_usage, cpu_util, scene_complexity, duration, gpu_type]):\n        raise TypeError(\"All inputs must be numbers.\")\n\n    if not (0 <= gpu_util <= 100 and 0 <= cpu_util <= 100 and vram_usage >= 0 and scene_complexity >= 0 and duration > 0 and gpu_type >0):\n        raise ValueError(\"Input values are out of range.\")\n\n\n    #Feature Normalization (min-max scaling)\n    gpu_util_norm = gpu_util / 100  \n    cpu_util_norm = cpu_util / 100\n    \n    # Assuming a reasonable VRAM maximum for normalization. Adjust as needed based on your target hardware\n    max_vram = 24 #GB\n    vram_usage_norm = vram_usage / max_vram\n\n    #Normalize scene complexity.  Assumes a reasonable range; adjust if needed.\n    max_scene_complexity = 10 # Adjust this based on your scene complexity scoring system.\n    scene_complexity_norm = scene_complexity/max_scene_complexity\n\n    #duration normalization (inverse relationship: lower is better)\n    #We assume a target frametime; adjust based on the desired frame rate (e.g., 1/90 for 90fps)\n    target_frame_time = 1/90 #seconds\n    duration_norm =  np.exp(-(duration - target_frame_time)**2/(2*(target_frame_time/3)**2)) #Gaussian weighting\n\n\n    #Optimization Logic (weighted average emphasizing frame time and resource usage)\n    weights = np.array([0.4, 0.2, 0.2, 0.1, 0.1]) #weights for duration, gpu, cpu, vram, scene complexity\n\n    normalized_features = np.array([duration_norm, 1-gpu_util_norm, 1-cpu_util_norm, 1-vram_usage_norm, 1-scene_complexity_norm ])\n\n    performance_score = np.dot(normalized_features, weights)\n\n    #Handle potential score out of bounds due to numerical error\n    performance_score = np.clip(performance_score, 0, 1)\n\n\n    return performance_score",
  "fitness_score": 0.9,
  "discovery_method": "funsearch",
  "generations_run": 50,
  "population_size": 30,
  "discovery_time": "2025-05-30T10:26:10.512381"
}
