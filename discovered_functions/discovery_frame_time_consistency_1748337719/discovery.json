{
  "discovery_id": "discovery_frame_time_consistency_1748337719",
  "domain": "frame_time_consistency",
  "timestamp": "2025-05-27T02:21:59.077752",
  "function_code": "import numpy as np\n\ndef vr_optimization_function(gpu_util, vram_usage, cpu_util, scene_complexity, duration, gpu_type):\n    \"\"\"\n    Optimizes VR performance for frame time consistency, aiming for a score between 0 and 1 (higher is better).\n\n    Args:\n        gpu_util (float): GPU utilization percentage (0-100).\n        vram_usage (float): VRAM usage in GB.\n        cpu_util (float): CPU utilization percentage (0-100).\n        scene_complexity (float): Scene complexity score (higher is more complex).\n        duration (float): Frame time duration in milliseconds.\n        gpu_type (float): GPU type (numerical representation, e.g., 2.0 for RTX 2080, 3.5 for RTX 3090).\n\n\n    Returns:\n        float: Optimized performance score between 0 and 1. Returns -1 if input is invalid.\n\n    Raises:\n        TypeError: if any input is not a number.\n        ValueError: if any input is outside the acceptable range.\n\n    \"\"\"\n\n    # Input validation\n    if not all(isinstance(x, (int, float)) for x in [gpu_util, vram_usage, cpu_util, scene_complexity, duration, gpu_type]):\n        raise TypeError(\"All inputs must be numbers.\")\n    if not (0 <= gpu_util <= 100 and 0 <= cpu_util <= 100 and vram_usage >= 0 and scene_complexity >= 0 and duration > 0 and gpu_type > 0):\n        raise ValueError(\"Invalid input range. Check GPU utilization, CPU utilization, VRAM usage, scene complexity, and duration.\")\n\n\n    #Feature Normalization (min-max scaling) to handle different scales and units.\n    gpu_util_norm = gpu_util / 100\n    cpu_util_norm = cpu_util / 100\n    vram_usage_norm = vram_usage / 16 # Assuming a max VRAM of 16GB as a reasonable upper bound. Adjust if needed.\n    #Assuming scene complexity and gpu_type are already somewhat normalized by their nature\n    duration_norm = 1 / (1 + duration) # Inverse scaling for duration; lower is better\n\n\n    #Optimization Logic:  Weighted average focusing on frame time consistency and resource usage\n    # Weights are adjusted based on importance.  These can be tuned based on specific needs.\n    weight_duration = 0.5  # Frame time is crucial for VR comfort\n    weight_gpu = 0.2       # GPU utilization should be high but not maxed out\n    weight_cpu = 0.15     # CPU impact on frame time\n    weight_vram = 0.1     # VRAM usage\n    weight_complexity = 0.05 # Scene complexity impact\n\n    # Penalize high GPU usage above a threshold (e.g., 90%) to prevent overheating and instability.\n    gpu_penalty = max(0, gpu_util_norm - 0.9) ** 2 # Quadratic penalty for values above 90%\n\n\n    optimized_score = weight_duration * duration_norm + weight_gpu * (gpu_util_norm - gpu_penalty) + weight_cpu * (1 - cpu_util_norm) + weight_vram * (1 - vram_usage_norm) + weight_complexity * (1/(1+scene_complexity)) #Inverse scaling for complexity\n\n\n    #Ensure score is within 0-1 range.  Clipping avoids potential floating-point errors.\n    return np.clip(optimized_score, 0, 1)",
  "fitness_score": 0.9,
  "discovery_method": "funsearch",
  "generations_run": 50,
  "population_size": 30,
  "discovery_time": "2025-05-27T02:21:59.068582"
}
