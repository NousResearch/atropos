{
  "discovery_id": "discovery_performance_efficiency_1748625987",
  "domain": "performance_efficiency",
  "timestamp": "2025-05-30T10:26:27.234676",
  "function_code": "import numpy as np\n\ndef vr_optimization_function(gpu_util, vram_usage, cpu_util, scene_complexity, duration, gpu_type):\n    \"\"\"\n    Optimizes VR performance focusing on GPU utilization.\n\n    Args:\n        gpu_util (float): GPU utilization percentage (0-100).\n        vram_usage (float): VRAM usage in GB.\n        cpu_util (float): CPU utilization percentage (0-100).\n        scene_complexity (float): Scene complexity score (higher is more complex).\n        duration (float): Frame render duration in seconds.\n        gpu_type (float): GPU type (numerical representation, e.g., 2.0 for RTX 2080, etc.).\n\n\n    Returns:\n        float: Optimized performance score between 0 and 1 (higher is better). \n               Returns -1 if input validation fails.\n\n    Raises:\n        TypeError: if any input is not a number.\n        ValueError: if any input is outside the expected range.\n\n    \"\"\"\n\n    # Input validation\n    inputs = [gpu_util, vram_usage, cpu_util, scene_complexity, duration, gpu_type]\n    if not all(isinstance(i, (int, float)) for i in inputs):\n        raise TypeError(\"All inputs must be numbers.\")\n    if not (0 <= gpu_util <= 100 and 0 <= cpu_util <= 100 and vram_usage >=0 and scene_complexity >=0 and duration > 0):\n        raise ValueError(\"Invalid input range. GPU and CPU utilization must be between 0 and 100, VRAM, Scene Complexity and Duration must be non-negative and Duration must be positive\")\n\n\n    #Feature Normalization (Min-Max scaling)\n    gpu_util_norm = gpu_util / 100.0  # Normalize GPU utilization to 0-1\n    cpu_util_norm = cpu_util / 100.0  # Normalize CPU utilization to 0-1\n\n    #Avoid division by zero\n    if duration == 0:\n      duration = 1e-9 #Assigning a very small value to avoid division by zero\n\n    #Optimization logic prioritizing GPU utilization and penalizing high VRAM/CPU usage & long duration\n    #Weight adjustments can be tuned based on specific priorities\n    gpu_weight = 0.6  \n    vram_weight = 0.2\n    cpu_weight = 0.1\n    duration_weight = 0.1\n\n    optimized_score = (gpu_weight * gpu_util_norm) - (vram_weight * (vram_usage / 16)) - (cpu_weight * cpu_util_norm) - (duration_weight * duration)\n\n\n    #Clamp the score between 0 and 1\n    optimized_score = np.clip(optimized_score, 0, 1)\n\n    return optimized_score",
  "fitness_score": 0.9,
  "discovery_method": "funsearch",
  "generations_run": 50,
  "population_size": 30,
  "discovery_time": "2025-05-30T10:26:27.234072"
}