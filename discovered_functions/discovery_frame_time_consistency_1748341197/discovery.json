{
  "discovery_id": "discovery_frame_time_consistency_1748341197",
  "domain": "frame_time_consistency",
  "timestamp": "2025-05-27T03:19:57.380873",
  "function_code": "import numpy as np\n\ndef vr_optimization_function(gpu_util, vram_usage, cpu_util, scene_complexity, duration, gpu_type):\n    \"\"\"\n    Optimizes VR performance for frame time consistency, aiming for a score between 0 and 1 (higher is better).\n\n    Args:\n        gpu_util (float): GPU utilization percentage (0-100).\n        vram_usage (float): VRAM usage in GB.\n        cpu_util (float): CPU utilization percentage (0-100).\n        scene_complexity (float): Scene complexity score (higher is more complex).\n        duration (float): Frame duration in seconds.\n        gpu_type (float): GPU type (e.g., 2.0 for a specific model, higher number for better GPUs).\n\n\n    Returns:\n        float: Optimized performance score between 0 and 1. Returns -1 if input is invalid.\n    \"\"\"\n\n    # Input validation\n    if not all(isinstance(x, (int, float)) for x in [gpu_util, vram_usage, cpu_util, scene_complexity, duration, gpu_type]):\n        print(\"Error: Input values must be numeric.\")\n        return -1\n    if not (0 <= gpu_util <= 100 and 0 <= cpu_util <= 100 and scene_complexity >=0 and duration > 0 and gpu_type > 0):\n        print(\"Error: Invalid input ranges.\")\n        return -1\n\n\n    # Feature normalization (min-max scaling)\n\n    gpu_util_norm = gpu_util / 100.0  # Normalize to 0-1 range.\n    cpu_util_norm = cpu_util / 100.0  # Normalize to 0-1 range.\n\n    #  Assume VRAM and Scene Complexity have reasonable upper bounds for normalization, adjust these if needed.\n    vram_max = 24 # Example:  adjust based on your expected VRAM range\n    scene_complexity_max = 10 # Example: adjust based on your scene complexity scoring\n    vram_usage_norm = vram_usage / vram_max\n    scene_complexity_norm = scene_complexity / scene_complexity_max\n\n    # GPU type weighting - higher is better\n    gpu_type_weight = np.clip(gpu_type/5,0,1) # example scaling: cap at 1\n\n    # Optimization logic (weighted average focusing on frame time consistency and resource utilization)\n    # Prioritize lower duration and lower resource utilization.  GPU is given more importance.\n    frame_time_weight = 0.5  # weight on Frame time.\n    resource_weight = 0.5  # weight on resource usage.\n\n    optimized_score = frame_time_weight * (1 / (duration + 0.0001)) + resource_weight * (1 - (gpu_util_norm + cpu_util_norm + vram_usage_norm + scene_complexity_norm) / 4 ) * gpu_type_weight #Avoid division by zero.\n\n    # Ensure score is within 0-1 range\n    optimized_score = np.clip(optimized_score, 0, 1)\n\n\n    return optimized_score",
  "fitness_score": 0.9,
  "discovery_method": "funsearch",
  "generations_run": 50,
  "population_size": 30,
  "discovery_time": "2025-05-27T03:19:57.379462"
}
