{
  "discovery_id": "discovery_performance_efficiency_1748337312",
  "domain": "performance_efficiency",
  "timestamp": "2025-05-27T02:15:12.642479",
  "function_code": "import numpy as np\n\ndef vr_optimization_function(gpu_util, vram_usage, cpu_util, scene_complexity, duration, gpu_type):\n    \"\"\"\n    Optimizes VR performance score based on GPU utilization.\n\n    Args:\n        gpu_util (float): GPU utilization percentage (0-100).\n        vram_usage (float): VRAM usage in GB.\n        cpu_util (float): CPU utilization percentage (0-100).\n        scene_complexity (float): Scene complexity score (higher is more complex).\n        duration (float): Frame duration in seconds.\n        gpu_type (float): GPU type (categorical, needs to be encoded numerically).\n\n    Returns:\n        float: Optimized performance score between 0 and 1 (higher is better). \n               Returns -1 if input validation fails.\n\n    Raises:\n        TypeError: if input types are invalid.\n        ValueError: if input values are out of range.\n    \"\"\"\n\n    # Input validation\n    if not all(isinstance(x, (int, float)) for x in [gpu_util, vram_usage, cpu_util, scene_complexity, duration, gpu_type]):\n        raise TypeError(\"All inputs must be numeric.\")\n\n    if not (0 <= gpu_util <= 100 and 0 <= cpu_util <= 100 and vram_usage >=0 and scene_complexity >= 0 and duration > 0):\n        raise ValueError(\"Invalid input range.  Check GPU utilization, CPU utilization, VRAM usage, scene complexity, and duration\")\n\n\n    # Feature normalization (min-max scaling)\n    gpu_util_norm = gpu_util / 100.0  \n    cpu_util_norm = cpu_util / 100.0\n    vram_usage_norm = vram_usage / 16 #assuming a maximum of 16GB VRAM is reasonable, adjust if necessary\n\n    #Prioritize GPU utilization\n    gpu_weight = 0.6\n\n    # Optimization logic (weighted average focusing on GPU utilization)\n    performance_score = gpu_weight * gpu_util_norm + (1 - gpu_weight) * (1 - (cpu_util_norm + vram_usage_norm + scene_complexity * 0.2 + duration * 0.1)) #Weight duration and scene complexity lower\n\n    # Handle potential negative scores due to normalization and weighting\n    performance_score = max(0, min(1, performance_score))\n\n    return performance_score",
  "fitness_score": 0.9,
  "discovery_method": "funsearch",
  "generations_run": 50,
  "population_size": 30,
  "discovery_time": "2025-05-27T02:15:12.641280"
}