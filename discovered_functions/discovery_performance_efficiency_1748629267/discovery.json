{
  "discovery_id": "discovery_performance_efficiency_1748629267",
  "domain": "performance_efficiency",
  "timestamp": "2025-05-30T11:21:07.819745",
  "function_code": "import numpy as np\n\ndef vr_optimization_function(gpu_util, vram_usage, cpu_util, scene_complexity, duration, gpu_type):\n    \"\"\"\n    Optimizes VR performance score based on GPU utilization.  Higher score indicates better performance.\n\n    Args:\n        gpu_util (float): GPU utilization percentage (0-100).\n        vram_usage (float): VRAM usage in GB.\n        cpu_util (float): CPU utilization percentage (0-100).\n        scene_complexity (float): Scene complexity score (higher is more complex).\n        duration (float): Frame rendering time in seconds.\n        gpu_type (float): GPU type (e.g., 1.0, 2.0, 3.5 representing different GPUs).\n\n\n    Returns:\n        float: Optimized performance score between 0 and 1 (inclusive). Returns -1 if input is invalid.\n    \"\"\"\n\n    # Input validation\n    if not all(isinstance(x, (int, float)) for x in [gpu_util, vram_usage, cpu_util, scene_complexity, duration, gpu_type]):\n        print(\"Error: Invalid input type. All inputs must be numeric.\")\n        return -1\n    if not 0 <= gpu_util <= 100 or not 0 <= cpu_util <= 100 or not scene_complexity >=0 or not duration > 0 or not gpu_type > 0:\n        print(\"Error: Invalid input range. Check GPU utilization, CPU utilization, scene complexity, duration, and GPU type.\")\n        return -1\n\n\n    # Feature normalization (min-max scaling)\n\n    gpu_util_norm = gpu_util / 100.0  # Normalize GPU utilization to 0-1 range\n    cpu_util_norm = cpu_util / 100.0   # Normalize CPU utilization to 0-1 range\n    \n    #Assuming VRAM usage is generally lower than 16GB. Adjust upper limit as needed based on your system's VRAM.\n    vram_usage_norm = vram_usage / 16.0 #Normalize VRAM usage. Adjust 16.0 as needed.\n    scene_complexity_norm = scene_complexity / 5 # Normalize Scene Complexity. Adjust 5 based on your maximum Scene Complexity Value.\n    duration_norm = 1/(duration + 0.001) #Inverse duration. Smaller duration is better, so we invert. Adding 0.001 to avoid division by zero.\n    gpu_type_norm = gpu_type / 5 # Assuming maximum GPU Type 5, adjust as needed\n\n\n    #Optimization logic: prioritizing GPU utilization and minimizing duration and VRAM usage.\n    #Weighting factors adjust the importance of each feature. Adjust weights as needed based on priorities.\n\n    gpu_weight = 0.6  # GPU utilization is the most important factor\n    duration_weight = 0.2 #Minimizing rendering time is important\n    vram_weight = 0.1 #VRAM Usage should be minimized\n    cpu_weight = 0.05 #CPU usage is less critical in this optimization scenario\n    scene_complexity_weight = 0.05 #Scene complexity should have a smaller effect than other factors\n\n\n    optimized_score = (gpu_weight * gpu_util_norm) + (duration_weight * duration_norm) - (vram_weight * vram_usage_norm) - (cpu_weight * cpu_util_norm) - (scene_complexity_weight * scene_complexity_norm)\n\n    #Ensure the score stays within the 0-1 range.\n    optimized_score = np.clip(optimized_score, 0, 1)\n\n\n    return optimized_score",
  "fitness_score": 0.9,
  "discovery_method": "funsearch",
  "generations_run": 50,
  "population_size": 30,
  "discovery_time": "2025-05-30T11:21:07.819100"
}