{
  "discovery_id": "discovery_comfort_optimization_1748629307",
  "domain": "comfort_optimization",
  "timestamp": "2025-05-30T11:21:47.672339",
  "function_code": "import numpy as np\n\ndef vr_optimization_function(gpu_util, vram_usage, cpu_util, scene_complexity, duration, gpu_type):\n    \"\"\"\n    Optimizes VR performance for maximum comfort score.\n\n    Args:\n        gpu_util (float): GPU utilization percentage (0-100).\n        vram_usage (float): VRAM usage in GB.\n        cpu_util (float): CPU utilization percentage (0-100).\n        scene_complexity (float): Scene complexity score (higher is more complex).\n        duration (float): Duration of VR experience in seconds.\n        gpu_type (float): GPU type (categorical, needs mapping for numerical processing).\n\n    Returns:\n        float: Optimized VR comfort score between 0 and 1 (inclusive).  Returns -1 if input is invalid.\n\n    Raises:\n        TypeError: if input is not a number.\n        ValueError: if input values are out of range.\n\n    \"\"\"\n\n    # Input validation\n    if not all(isinstance(x, (int, float)) for x in [gpu_util, vram_usage, cpu_util, scene_complexity, duration, gpu_type]):\n        raise TypeError(\"All inputs must be numbers.\")\n\n    if not (0 <= gpu_util <= 100 and 0 <= cpu_util <= 100 and scene_complexity >=0 and duration > 0 and gpu_type >= 0):\n        raise ValueError(\"Invalid input range. GPU/CPU utilization (0-100), Scene Complexity (>=0), Duration (>0), GPU Type (>=0).\")\n\n\n    # Feature normalization (min-max scaling)\n    gpu_util_norm = gpu_util / 100.0  \n    cpu_util_norm = cpu_util / 100.0\n    #Assuming VRAM usage is capped, otherwise needs range analysis based on hardware.\n    vram_usage_norm = vram_usage / 8.0 #Example cap of 8GB. Adjust as needed for realistic cap.\n    \n    #Handle GPU type, assuming it is a categorical variable represented numerically\n    #Replace with your mapping logic if necessary\n    gpu_type_norm = gpu_type / 3.5 #Example mapping - adjust based on the scale of gpu_type\n\n    #Mathematical optimization logic (weighted average with penalties)\n    #Weights are adjusted based on perceived impact.  Adjust these based on your data.\n    comfort_score = 0.3 * (1 - gpu_util_norm) + 0.2 * (1 - cpu_util_norm) + 0.2 * (1 - vram_usage_norm) + 0.2 * (1 / (1 + scene_complexity)) + 0.1 * (1/duration)\n\n\n    #Penalty for high GPU type (Assuming higher values represent less efficient GPUs).\n    comfort_score -= 0.1* gpu_type_norm\n\n    #Clip the score to be between 0 and 1\n    comfort_score = np.clip(comfort_score, 0, 1)\n\n\n    return comfort_score",
  "fitness_score": 0.9,
  "discovery_method": "funsearch",
  "generations_run": 50,
  "population_size": 30,
  "discovery_time": "2025-05-30T11:21:47.670605"
}
