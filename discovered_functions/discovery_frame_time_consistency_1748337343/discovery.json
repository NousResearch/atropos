{
  "discovery_id": "discovery_frame_time_consistency_1748337343",
  "domain": "frame_time_consistency",
  "timestamp": "2025-05-27T02:15:43.345471",
  "function_code": "import numpy as np\n\ndef vr_optimization_function(gpu_util, vram_usage, cpu_util, scene_complexity, duration, gpu_type):\n    \"\"\"\n    Optimizes VR performance for frame time consistency, aiming for a score between 0 and 1 (higher is better).\n\n    Args:\n        gpu_util (float): GPU utilization percentage (0-100).\n        vram_usage (float): VRAM usage in GB.\n        cpu_util (float): CPU utilization percentage (0-100).\n        scene_complexity (float): Scene complexity score (higher is more complex).\n        duration (float): Frame time duration in seconds.\n        gpu_type (float): GPU type (numerical representation, e.g., 2.0 for RTX 2080,  etc.).\n\n    Returns:\n        float: Optimized performance score between 0 and 1. Returns -1 if input is invalid.\n    \"\"\"\n\n    # Input validation\n    if not all(isinstance(arg, (int, float)) for arg in [gpu_util, vram_usage, cpu_util, scene_complexity, duration, gpu_type]):\n        print(\"Error: All inputs must be numeric.\")\n        return -1\n    if not 0 <= gpu_util <= 100 or not 0 <= cpu_util <= 100 or not duration >0 or not scene_complexity >=0:\n        print(\"Error: Invalid input range for gpu_util, cpu_util, duration or scene_complexity.\")\n        return -1\n    if vram_usage < 0 :\n        print(\"Error: Invalid input range for vram_usage.\")\n        return -1\n\n\n    # Feature normalization (min-max scaling)\n    gpu_util_norm = gpu_util / 100.0\n    cpu_util_norm = cpu_util / 100.0\n    vram_usage_norm = vram_usage / 8 # Assuming a maximum of 8GB VRAM as a reasonable upper bound. Adjust if needed.\n\n\n    # Optimization logic: Weighted average focusing on frame time and resource utilization balance.\n    # Lower duration and resource utilization are preferred.  Weights are adjusted based on importance.\n\n    weight_duration = 0.5  # High weight for frame time consistency\n    weight_gpu = 0.2      # Moderate weight for GPU usage\n    weight_cpu = 0.2     # Moderate weight for CPU usage\n    weight_vram = 0.1     # Lower weight for VRAM usage (relative to GPU/CPU)\n\n    # Penalty for high scene complexity\n    complexity_penalty = 1.0 / (1 + scene_complexity) #Decreases as complexity increases\n\n\n    #Inverse duration to prioritize lower frame times\n    duration_score = 1/duration if duration > 0 else 0\n\n    optimized_score = (weight_duration * duration_score + \n                       weight_gpu * (1 - gpu_util_norm) + \n                       weight_cpu * (1 - cpu_util_norm) +\n                       weight_vram * (1 - vram_usage_norm)) * complexity_penalty\n\n    #Ensure score is within 0-1 range\n    optimized_score = np.clip(optimized_score, 0, 1)\n\n    return optimized_score",
  "fitness_score": 0.9,
  "discovery_method": "funsearch",
  "generations_run": 50,
  "population_size": 30,
  "discovery_time": "2025-05-27T02:15:43.343926"
}
