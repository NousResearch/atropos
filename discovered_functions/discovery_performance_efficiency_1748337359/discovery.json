{
  "discovery_id": "discovery_performance_efficiency_1748337359",
  "domain": "performance_efficiency",
  "timestamp": "2025-05-27T02:15:59.419864",
  "function_code": "import numpy as np\n\ndef vr_optimization_function(gpu_util, vram_usage, cpu_util, scene_complexity, duration, gpu_type):\n    \"\"\"\n    Optimizes VR performance focusing on GPU utilization.\n\n    Args:\n        gpu_util (float): GPU utilization percentage (0-100).\n        vram_usage (float): VRAM usage in GB.\n        cpu_util (float): CPU utilization percentage (0-100).\n        scene_complexity (float): Scene complexity score (higher is more complex).\n        duration (float): Frame rendering duration in seconds.\n        gpu_type (float): GPU type (numerical representation, e.g., 2.0 for RTX 2080).\n\n\n    Returns:\n        float: Optimized performance score between 0 and 1 (higher is better).  Returns -1 if input is invalid.\n\n    Raises:\n        TypeError: if input is not a number.\n        ValueError: if input is outside the acceptable range.\n\n    \"\"\"\n\n    # Input validation\n    input_features = [gpu_util, vram_usage, cpu_util, scene_complexity, duration, gpu_type]\n    if not all(isinstance(i, (int, float)) for i in input_features):\n        raise TypeError(\"All input features must be numbers.\")\n    if not 0 <= gpu_util <= 100 or not 0 <= cpu_util <= 100 or not scene_complexity >=0 or not duration > 0 or not gpu_type >0 :\n        raise ValueError(\"Invalid input range. gpu_util and cpu_util should be between 0 and 100. scene_complexity and duration should be positive.\")\n\n\n    # Feature normalization (min-max scaling)\n    gpu_util_norm = gpu_util / 100.0\n    cpu_util_norm = cpu_util / 100.0\n    vram_usage_norm = vram_usage / 16  # Assuming a max VRAM of 16GB as a reasonable upper bound. Adjust as needed.\n    scene_complexity_norm = scene_complexity / 10 #Assumes a reasonable upper bound of 10 for scene complexity. Adjust as needed.\n    duration_norm = 1/(duration + 0.001) #inverse duration, shorter is better. adding small constant to prevent division by zero\n\n\n    # Optimization logic (weighted average focusing on GPU utilization)\n    weights = np.array([0.6, 0.1, 0.1, 0.1, 0.1]) #weighting GPU utilization higher\n    normalized_features = np.array([gpu_util_norm, vram_usage_norm, cpu_util_norm, scene_complexity_norm, duration_norm])\n\n    performance_score = np.sum(weights * normalized_features)\n\n\n    #Ensure score is within 0-1 range\n    performance_score = max(0, min(1, performance_score))\n\n\n    return performance_score",
  "fitness_score": 0.9,
  "discovery_method": "funsearch",
  "generations_run": 50,
  "population_size": 30,
  "discovery_time": "2025-05-27T02:15:59.418579"
}
