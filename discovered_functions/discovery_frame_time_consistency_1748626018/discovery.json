{
  "discovery_id": "discovery_frame_time_consistency_1748626018",
  "domain": "frame_time_consistency",
  "timestamp": "2025-05-30T10:26:58.050531",
  "function_code": "import numpy as np\n\ndef vr_optimization_function(gpu_util, vram_usage, cpu_util, scene_complexity, duration, gpu_type):\n    \"\"\"\n    Optimizes VR performance for frame time consistency and comfort.\n\n    Args:\n        gpu_util (float): GPU utilization percentage (0-100).\n        vram_usage (float): VRAM usage in GB.\n        cpu_util (float): CPU utilization percentage (0-100).\n        scene_complexity (float): Scene complexity score (higher is more complex).\n        duration (float): Frame time in seconds.\n        gpu_type (float): GPU type (numerical representation, e.g., 2.0 for RTX 2080).\n\n\n    Returns:\n        float: Optimized performance score between 0 and 1 (inclusive).  Returns -1 if input is invalid.\n\n    Raises:\n        TypeError: If any input is not a number.\n        ValueError: If any input is outside the expected range.\n\n    \"\"\"\n\n    # Input validation\n    if not all(isinstance(x, (int, float)) for x in [gpu_util, vram_usage, cpu_util, scene_complexity, duration, gpu_type]):\n        raise TypeError(\"All inputs must be numbers.\")\n\n    if not (0 <= gpu_util <= 100 and 0 <= cpu_util <= 100 and vram_usage >=0 and scene_complexity >= 0 and duration > 0):\n        raise ValueError(\"Invalid input range. GPU/CPU utilization (0-100%), VRAM usage >=0, Scene complexity >=0, duration > 0\")\n\n\n    # Feature normalization (min-max scaling)\n    gpu_util_norm = gpu_util / 100.0\n    cpu_util_norm = cpu_util / 100.0\n    vram_usage_norm = np.clip(vram_usage / 16, 0,1) # Assuming 16GB as a reasonable upper bound for VRAM. Adjust if needed.\n\n    #scene_complexity_norm = scene_complexity / 10 #Assuming a max complexity of 10. Adjust if needed.\n    scene_complexity_norm = 1/(1+scene_complexity) #Inverse relationship: higher complexity means lower score\n\n\n    #This is a simplification, consider more sophisticated weighting based on VR hardware and application specifics.\n    duration_norm = 1/(1+duration) # shorter duration is better.\n\n    # Optimization logic (weighted average focusing on frame time consistency and resource utilization)\n\n    weights = np.array([0.3, 0.2, 0.2, 0.1, 0.2]) # Adjust weights based on priorities. Frame time (duration) is heavily weighted.\n\n    normalized_features = np.array([1 - gpu_util_norm, 1 - cpu_util_norm, 1- vram_usage_norm, scene_complexity_norm, duration_norm])\n\n\n    performance_score = np.dot(normalized_features, weights)\n\n\n    return np.clip(performance_score, 0, 1) #Ensure score is within [0,1] range.",
  "fitness_score": 0.9,
  "discovery_method": "funsearch",
  "generations_run": 50,
  "population_size": 30,
  "discovery_time": "2025-05-30T10:26:58.049587"
}