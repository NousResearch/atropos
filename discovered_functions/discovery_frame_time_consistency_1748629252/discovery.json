{
  "discovery_id": "discovery_frame_time_consistency_1748629252",
  "domain": "frame_time_consistency",
  "timestamp": "2025-05-30T11:20:52.095946",
  "function_code": "import numpy as np\n\ndef vr_optimization_function(gpu_util, vram_usage, cpu_util, scene_complexity, duration, gpu_type):\n    \"\"\"\n    Optimizes VR performance for frame time consistency, aiming for a score between 0 and 1.\n\n    Args:\n        gpu_util (float): GPU utilization percentage (0-100).\n        vram_usage (float): VRAM usage in GB.\n        cpu_util (float): CPU utilization percentage (0-100).\n        scene_complexity (float): Scene complexity score (higher is more complex).\n        duration (float): Frame duration in seconds.\n        gpu_type (float): GPU type (numerical representation, e.g., 1 for GTX 1080, 2 for RTX 2080 etc.).\n\n    Returns:\n        float: Optimized performance score (0-1, higher is better). Returns -1 if input is invalid.\n    \"\"\"\n\n    # Input validation\n    try:\n        if not all(isinstance(i, (int, float)) for i in [gpu_util, vram_usage, cpu_util, scene_complexity, duration, gpu_type]):\n            raise ValueError(\"All inputs must be numeric.\")\n        if not 0 <= gpu_util <= 100 or not 0 <= cpu_util <= 100:\n            raise ValueError(\"GPU and CPU utilization must be between 0 and 100.\")\n        if vram_usage < 0 or scene_complexity < 0 or duration < 0 or gpu_type < 0:\n            raise ValueError(\"VRAM usage, scene complexity, duration, and GPU type cannot be negative.\")\n\n    except ValueError as e:\n        print(f\"Error: {e}\")\n        return -1\n\n\n    # Feature normalization (min-max scaling)\n    gpu_util_norm = gpu_util / 100  # Normalize to 0-1\n    cpu_util_norm = cpu_util / 100  # Normalize to 0-1\n\n    #  We assume scene complexity is already relatively scaled; we'll just cap it\n    scene_complexity_norm = min(scene_complexity, 5) / 5  # Cap at 5 and normalize\n\n    # GPU type influence -  assuming higher number indicates better performance\n    gpu_type_influence = gpu_type / (gpu_type + 1) # Example influence function. Adjust as needed based on your GPU type mapping.\n\n    # Frame time consistency penalty\n    frame_time_consistency = np.exp(-duration) # Exponentially penalize longer durations\n\n\n    # Optimization logic (weighted average) - adjust weights as needed\n    weights = np.array([0.25, 0.15, 0.25, 0.2, 0.15, 0.15]) # Weights for gpu,vram,cpu,scene,duration,gpu_type respectively\n\n    normalized_features = np.array([gpu_util_norm, vram_usage, cpu_util_norm, scene_complexity_norm, frame_time_consistency, gpu_type_influence ])\n    \n    #Avoid division by zero if all weights are zero.\n    if np.sum(weights) == 0:\n        return 0\n\n    performance_score = np.sum(weights * normalized_features) / np.sum(weights)\n\n    # Ensure score is within 0-1 range\n    performance_score = max(0, min(1, performance_score))\n\n    return performance_score",
  "fitness_score": 0.9,
  "discovery_method": "funsearch",
  "generations_run": 50,
  "population_size": 30,
  "discovery_time": "2025-05-30T11:20:52.095246"
}
