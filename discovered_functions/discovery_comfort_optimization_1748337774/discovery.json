{
  "discovery_id": "discovery_comfort_optimization_1748337774",
  "domain": "comfort_optimization",
  "timestamp": "2025-05-27T02:22:54.595053",
  "function_code": "import numpy as np\n\ndef vr_optimization_function(gpu_util, vram_usage, cpu_util, scene_complexity, duration, gpu_type):\n    \"\"\"\n    Optimizes VR performance for maximum comfort score.\n\n    Args:\n        gpu_util (float): GPU utilization (%).\n        vram_usage (float): VRAM usage (GB).\n        cpu_util (float): CPU utilization (%).\n        scene_complexity (float): Scene complexity score (higher is more complex).\n        duration (float): Duration of VR experience (seconds).\n        gpu_type (float): GPU type (numerical representation, higher is better).\n\n\n    Returns:\n        float: Optimized performance score between 0 and 1 (inclusive).  Returns -1 if input is invalid.\n\n    Raises:\n        TypeError: If any input is not a number.\n        ValueError: If any input is outside the expected range.\n    \"\"\"\n\n    # Input validation\n    if not all(isinstance(x, (int, float)) for x in [gpu_util, vram_usage, cpu_util, scene_complexity, duration, gpu_type]):\n        raise TypeError(\"All inputs must be numbers.\")\n\n    if not (0 <= gpu_util <= 100 and 0 <= cpu_util <= 100 and vram_usage >=0 and scene_complexity >=0 and duration > 0 and gpu_type > 0):\n        raise ValueError(\"Inputs are out of range. Check gpu_util, cpu_util, vram_usage, scene_complexity, duration and gpu_type values.\")\n\n\n    # Feature normalization (min-max scaling)\n    gpu_util_norm = gpu_util / 100.0\n    cpu_util_norm = cpu_util / 100.0\n    # Assuming VRAM usage has an upper bound of 16GB for normalization\n    vram_usage_norm = min(vram_usage / 16.0,1.0) #Cap at 1.0 to avoid values >1\n    # Normalize scene complexity (assuming a reasonable max complexity of 10)\n    scene_complexity_norm = min(scene_complexity / 10.0,1.0) #Cap at 1.0\n    duration_norm = 1.0 / (1 + duration) #Inverse relationship: shorter duration is better\n\n\n    # Optimization logic (weighted average with penalties)\n\n    # Weights reflect importance; adjust based on your specific needs.\n    weights = np.array([0.25, 0.2, 0.2, 0.15, 0.1, 0.1]) #GPU,VRAM,CPU,Scene,Duration,GPUtype\n\n    #Penalties for high utilization\n    gpu_util_penalty = 1 - (1-gpu_util_norm)**2 #Steeper penalty for higher GPU utilization.\n    cpu_util_penalty = 1 - (1-cpu_util_norm)**2\n\n    normalized_features = np.array([1-gpu_util_penalty, 1-vram_usage_norm, 1-cpu_util_penalty, 1-scene_complexity_norm, duration_norm, gpu_type/5.0]) #Assuming a max gpu type of 5.\n\n    #Weighted score\n    weighted_score = np.sum(normalized_features * weights)\n\n    #Ensure score is within 0-1 range\n    optimized_score = max(0, min(1, weighted_score))\n\n    return optimized_score",
  "fitness_score": 0.9,
  "discovery_method": "funsearch",
  "generations_run": 50,
  "population_size": 30,
  "discovery_time": "2025-05-27T02:22:54.594296"
}
