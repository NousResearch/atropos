{
  "discovery_id": "discovery_performance_efficiency_1748337735",
  "domain": "performance_efficiency",
  "timestamp": "2025-05-27T02:22:15.524957",
  "function_code": "import numpy as np\n\ndef vr_optimization_function(gpu_util, vram_usage, cpu_util, scene_complexity, duration, gpu_type):\n    \"\"\"\n    Optimizes VR performance score based on GPU utilization.  Higher score indicates better optimization.\n\n    Args:\n        gpu_util (float): GPU utilization percentage (0-100).\n        vram_usage (float): VRAM usage in GB.\n        cpu_util (float): CPU utilization percentage (0-100).\n        scene_complexity (float): Scene complexity score (higher is more complex).\n        duration (float): Frame rendering duration in seconds.\n        gpu_type (float): GPU type (e.g., 2.0 for RTX 2080, 3.5 for RTX 3090, higher is better).\n\n    Returns:\n        float: Optimized performance score between 0 and 1 (inclusive). Returns -1 if input is invalid.\n\n    Raises:\n        TypeError: if any input is not a number.\n        ValueError: if any input is outside the acceptable range.\n\n    \"\"\"\n\n    # Input validation\n    if not all(isinstance(x, (int, float)) for x in [gpu_util, vram_usage, cpu_util, scene_complexity, duration, gpu_type]):\n        raise TypeError(\"All inputs must be numbers.\")\n\n    if not (0 <= gpu_util <= 100 and 0 <= cpu_util <= 100 and vram_usage >= 0 and scene_complexity >= 0 and duration > 0 and gpu_type > 0):\n        raise ValueError(\"Invalid input range. Check your input values.\")\n\n\n    # Feature normalization (min-max scaling)\n    gpu_util_norm = gpu_util / 100  #Scale GPU utilization to 0-1\n    cpu_util_norm = cpu_util / 100  #Scale CPU utilization to 0-1\n\n    #Consider VRAM usage penalty - higher VRAM usage reduces score.  Adjust scaling as needed\n    vram_penalty = 1 / (1 + vram_usage)\n\n    #Scene complexity impact - higher complexity reduces score.  Adjust scaling as needed.\n    complexity_penalty = 1 / (1 + scene_complexity)\n\n    #GPU type boost - higher GPU type increases score\n    gpu_type_boost = np.clip(gpu_type / 4.0, 0, 1) #Clip to prevent overshooting\n\n\n    # Optimization logic: Prioritize GPU utilization, penalize high CPU, VRAM and scene complexity, boost based on GPU type.\n    #Adjust weights as needed to tune the optimization\n    performance_score = 0.5 * gpu_util_norm + 0.2 * (1 - cpu_util_norm) + 0.1 * vram_penalty + 0.1 * complexity_penalty + 0.1 * gpu_type_boost\n\n    #Handle duration - shorter duration is better.  Adjust scaling as needed.\n    duration_weight = 0.1\n    performance_score -= duration_weight * min(duration, 1) # penalize if duration exceeds 1 second\n\n\n    # Ensure score is within 0-1 range\n    return np.clip(performance_score, 0, 1)",
  "fitness_score": 0.9,
  "discovery_method": "funsearch",
  "generations_run": 50,
  "population_size": 30,
  "discovery_time": "2025-05-27T02:22:15.524045"
}
