{
  "discovery_id": "discovery_performance_efficiency_1748337782",
  "domain": "performance_efficiency",
  "timestamp": "2025-05-27T02:23:02.575288",
  "function_code": "import numpy as np\n\ndef vr_optimization_function(gpu_util, vram_usage, cpu_util, scene_complexity, duration, gpu_type):\n    \"\"\"\n    Optimizes VR performance focusing on GPU utilization.\n\n    Args:\n        gpu_util (float): GPU utilization percentage (0-100).\n        vram_usage (float): VRAM usage in GB.\n        cpu_util (float): CPU utilization percentage (0-100).\n        scene_complexity (float): Scene complexity score (higher is more complex).\n        duration (float): Frame rendering duration in seconds.\n        gpu_type (float): GPU type (numerical representation, higher is better).\n\n    Returns:\n        float: Optimized performance score between 0 and 1 (higher is better). \n               Returns -1 if input validation fails.\n\n    Raises:\n        TypeError: if any input is not a number.\n        ValueError: if any input is out of range.\n\n    \"\"\"\n\n    # Input validation\n    try:\n        if not all(isinstance(x, (int, float)) for x in [gpu_util, vram_usage, cpu_util, scene_complexity, duration, gpu_type]):\n            raise TypeError(\"All inputs must be numbers.\")\n        if not 0 <= gpu_util <= 100 or not 0 <= cpu_util <= 100 or not scene_complexity >=0 or not duration > 0 or not gpu_type >=0:\n            raise ValueError(\"Invalid input range.  Check GPU utilization, CPU utilization, scene complexity, and duration.\")\n\n    except (TypeError, ValueError) as e:\n        print(f\"Error: {e}\")\n        return -1\n\n\n    # Feature normalization (min-max scaling)\n    gpu_util_norm = gpu_util / 100  #already normalized\n    vram_usage_norm = vram_usage / 16  # Assuming a maximum of 16GB VRAM for normalization. Adjust as needed.\n    cpu_util_norm = cpu_util / 100 #already normalized\n    #Assuming scene complexity is already scaled appropriately. No normalization needed.\n    scene_complexity_norm = scene_complexity\n    duration_norm = 1/(1+duration) #inverse scaling for duration, lower duration is better\n\n    gpu_type_norm = gpu_type / 5 # Assuming a maximum GPU type score of 5. Adjust as needed.\n\n    # Optimization logic (weights can be adjusted based on priorities)\n    gpu_weight = 0.5  # Higher weight given to GPU utilization\n    vram_weight = 0.1\n    cpu_weight = 0.1\n    scene_weight = 0.2  \n    duration_weight = 0.1\n    gpu_type_weight = 0.1\n\n\n    optimized_score = (gpu_weight * gpu_util_norm) + (vram_weight * (1 - vram_usage_norm)) + (cpu_weight * (1-cpu_util_norm)) + (scene_weight * (1/(1+scene_complexity_norm))) + (duration_weight * duration_norm) + (gpu_type_weight * gpu_type_norm)\n\n\n    #Ensure score is within 0-1 range\n    optimized_score = np.clip(optimized_score, 0, 1)\n\n    return optimized_score",
  "fitness_score": 0.9,
  "discovery_method": "funsearch",
  "generations_run": 50,
  "population_size": 30,
  "discovery_time": "2025-05-27T02:23:02.573528"
}
