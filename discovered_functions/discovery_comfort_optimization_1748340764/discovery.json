{
  "discovery_id": "discovery_comfort_optimization_1748340764",
  "domain": "comfort_optimization",
  "timestamp": "2025-05-27T03:12:44.878568",
  "function_code": "import numpy as np\n\ndef vr_optimization_function(gpu_util, vram_usage, cpu_util, scene_complexity, duration, gpu_type):\n    \"\"\"\n    Optimizes VR performance for maximum comfort score.\n\n    Args:\n        gpu_util (float): GPU utilization percentage (0-100).\n        vram_usage (float): VRAM usage in GB.\n        cpu_util (float): CPU utilization percentage (0-100).\n        scene_complexity (float): Scene complexity score (higher is more complex).\n        duration (float): Duration of VR experience in seconds.\n        gpu_type (float): GPU type (e.g., 2.0 for mid-range, 3.5 for high-end).\n\n    Returns:\n        float: Optimized performance score between 0 and 1 (higher is better). \n               Returns -1 if input validation fails.\n\n    Raises:\n        TypeError: if any input is not a number.\n        ValueError: if any input is outside the acceptable range.\n\n    \"\"\"\n\n    # Input validation\n    if not all(isinstance(x, (int, float)) for x in [gpu_util, vram_usage, cpu_util, scene_complexity, duration, gpu_type]):\n        raise TypeError(\"All inputs must be numbers.\")\n    if not (0 <= gpu_util <= 100 and 0 <= cpu_util <= 100 and vram_usage >= 0 and scene_complexity >= 0 and duration > 0 and gpu_type > 0):\n        raise ValueError(\"Invalid input values. Check ranges for each parameter.\")\n\n\n    # Feature normalization (min-max scaling) -  Improves robustness across different hardware/scenes\n    gpu_util_norm = gpu_util / 100.0\n    cpu_util_norm = cpu_util / 100.0\n    vram_usage_norm = vram_usage / 16  # Assuming a maximum of 16GB VRAM as a reasonable upper bound. Adjust as needed.\n    \n    #Consider GPU type impact - higher is better\n    gpu_type_weight = 1 + (gpu_type - 2) / 2 # Weighs GPU type impact (mid-range as baseline)\n\n\n    # Optimization logic (weighted average with penalties for high utilization and complexity)\n    #Weights are chosen empirically - adjust based on experimentation and VR system specific priorities\n    comfort_score = (0.3 * (1 - gpu_util_norm) +  # Penalize high GPU utilization\n                     0.25 * (1 - cpu_util_norm) +  # Penalize high CPU utilization\n                     0.2 * (1 - vram_usage_norm) +  # Penalize high VRAM usage\n                     0.15 * (1 / (1 + scene_complexity)) + # Inverse relationship with scene complexity\n                     0.1 * (1/duration) * gpu_type_weight # Reward shorter duration and better GPU type\n                     )\n\n    #Clamp the score to 0-1 range\n    return max(0, min(1, comfort_score))",
  "fitness_score": 0.9,
  "discovery_method": "funsearch",
  "generations_run": 50,
  "population_size": 30,
  "discovery_time": "2025-05-27T03:12:44.876866"
}
