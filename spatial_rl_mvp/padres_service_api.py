# spatial_rl_mvp/padres_service_api.py

import asyncio
import json  # For main test block printing
import uuid
from typing import Any, Dict, List, Optional

from fastapi import FastAPI, HTTPException
from pydantic import BaseModel, Field

# Import necessary components from spatial_env.py
# We might need to refactor spatial_env.py slightly if classes are not easily importable
# or if global state there interferes.
from .spatial_env import (  # MVPPhysicsSimulator no longer directly needed here
    ObjectState,
    SpatialEnvironmentMVP,
    SpatialTask,
)

app = FastAPI(
    title="Padres Environment Service API",
    description="Provides HTTP endpoints to interact with the Padres (PyBullet) simulation environment.",
    version="0.1.3",  # Version bump for functional endpoints
)

# --- In-memory store for active environments ---
# Key: environment_id (str), Value: instance of SpatialEnvironmentMVP
# WARNING: This is not suitable for production with multiple workers/instances.
# For production, a shared store (e.g., Redis, DB) or a different architecture would be needed.
active_environments: Dict[str, SpatialEnvironmentMVP] = {}

# --- Pydantic Models for API ---


class SetupEnvironmentRequest(BaseModel):
    task_name: str = Field(..., example="FindAndPlaceRedCubeNearBlueSphere")
    task_description: Optional[str] = (
        "Default task: Place the red cube near the blue sphere while on the same X side as the blue sphere (relative to origin)."
    )
    goal_description: Optional[str] = (
        "Red cube X has same sign as Blue sphere X. Distance ~1.0 unit."
    )
    # Allow specifying initial objects for more control, otherwise defaults are used.
    initial_objects: Optional[List[ObjectState]] = None
    task_parameters: Dict[str, Any] = Field(
        default_factory=dict,
        example={
            "target_object_id": "red_cube",
            "reference_object_id": "blue_sphere",
            "target_distance": 1.0,
        },
    )


class EnvironmentInfoResponse(BaseModel):
    environment_id: str
    task_id: str
    llm_prompt: str  # The prompt generated by the environment for this task setup
    initial_state_viz: List[Dict[str, Any]]
    message: str = "Environment initialized successfully."


class ExecuteActionRequest(BaseModel):
    action_name: str = Field(
        ..., example="move_object"
    )  # This should match "action_type" in LLM response
    action_parameters: Dict[str, Any] = Field(
        ..., example={"object_id": "red_cube", "target_position": [1.0, 2.0, 0.5]}
    )


class ActionResultResponse(BaseModel):
    environment_id: str
    new_state_viz: List[Dict[str, Any]]
    reward: float
    done: bool
    observation: Optional[str] = None
    message: str = "Action executed."


# No longer using ServiceSpatialEnvironment wrapper as SpatialEnvironmentMVP is now more suitable.

# --- Task Definition Store (Conceptual) ---
# In a real system, this would come from a database or config files.
PREDEFINED_TASK_TEMPLATES: Dict[str, Dict[str, Any]] = {
    "DefaultFindAndPlace": {
        "description": "The red cube and blue sphere are present. Move the red cube very close to the blue sphere, ensuring they are on the same side of the YZ plane (e.g., both have positive or both have negative X coordinates).",
        "goal_description": "The red_cube and blue_sphere have x-coordinates with the same sign. The distance between their centers is approximately 1.0 unit.",
        "initial_objects": [
            {
                "id": "red_cube",
                "type": "cube",
                "position": [2.0, 0.5, 0.5],
                "scale": [1, 1, 1],
                "color_rgba": [1, 0, 0, 1],
            },
            {
                "id": "blue_sphere",
                "type": "sphere",
                "position": [2.5, -0.5, 0.5],
                "scale": [1, 1, 1],
                "color_rgba": [0, 0, 1, 1],
            },
        ],
        "default_task_parameters": {
            "target_object_id": "red_cube",
            "reference_object_id": "blue_sphere",
            "target_distance": 1.0,
        },
    },
    "SimpleRedCubeBlueSphereOpposite": {
        "description": "A red cube and a blue sphere are on opposite sides of the YZ plane. Move the red cube close to the blue sphere while maintaining this opposite-side relationship.",
        "goal_description": "Red cube X has the opposite sign of Blue sphere X. Distance between them is ~0.5 units.",
        "initial_objects": [
            {
                "id": "red_cube",
                "type": "cube",
                "position": [2.0, 0.2, 0.5],
                "scale": [0.8, 0.8, 0.8],
                "color_rgba": [1, 0, 0, 1],
            },
            {
                "id": "blue_sphere",
                "type": "sphere",
                "position": [-1.5, -0.3, 0.5],
                "scale": [0.7, 0.7, 0.7],
                "color_rgba": [0, 0, 1, 1],
            },
        ],
        "default_task_parameters": {
            "target_object_id": "red_cube",
            "reference_object_id": "blue_sphere",
            "target_distance": 0.5,
        },
    },
}


def get_task_definition(
    task_name_from_request: str,
    request_initial_objects: Optional[List[ObjectState]],
    request_task_params: Dict[str, Any],
) -> SpatialTask:
    template = PREDEFINED_TASK_TEMPLATES.get(task_name_from_request)
    env_id_suffix = uuid.uuid4().hex[:4]  # Short unique suffix for task_id
    if template:
        print(f"Found predefined task template: {task_name_from_request}")
        initial_objects = (
            request_initial_objects
            if request_initial_objects is not None
            else [ObjectState(**obj_data) for obj_data in template["initial_objects"]]
        )
        # Merge task_parameters from request with defaults from template, request takes precedence
        merged_task_params = {
            **template.get("default_task_parameters", {}),
            **request_task_params,
        }

        task = SpatialTask(
            task_id=f"{task_name_from_request}_{env_id_suffix}",
            description=(
                template["description"]
                if not request.task_description
                else request.task_description
            ),
            initial_objects=initial_objects,
            goal_description=(
                template["goal_description"]
                if not request.goal_description
                else request.goal_description
            ),
            target_object_id=merged_task_params["target_object_id"],
            reference_object_id=merged_task_params["reference_object_id"],
            target_distance=float(merged_task_params["target_distance"]),
        )
    else:
        print(
            "Warning: Task name "{task_name_from_request}' not in predefined templates. Creating generic task based on request."
        )
        initial_objects = (
            request_initial_objects
            if request_initial_objects is not None
            else [  # Minimal default if no template and no objects
                ObjectState(id="default_target", type="cube", position=[1, 0, 0.5]),
                ObjectState(id="default_re", type="sphere", position=[-1, 0, 0.5]),
            ]
        )
        target_id = request_task_params.get(
            "target_object_id",
            initial_objects[0].id if initial_objects else "unknown_target",
        )
        ref_id = request_task_params.get(
            "reference_object_id",
            initial_objects[1].id if len(initial_objects) > 1 else "unknown_re",
        )
        task = SpatialTask(
            task_id=f"{task_name_from_request}_{env_id_suffix}",
            description=request.task_description
            or f"Perform task: {task_name_from_request}",
            initial_objects=initial_objects,
            goal_description=request.goal_description or "Achieve task objective.",
            target_object_id=target_id,
            reference_object_id=ref_id,
            target_distance=float(request_task_params.get("target_distance", 1.0)),
        )
    # Ensure target and reference objects are in the list
    obj_ids_in_task = {obj.id for obj in task.initial_objects}
    if task.target_object_id not in obj_ids_in_task:
        task.initial_objects.append(
            ObjectState(
                id=task.target_object_id,
                type="cube",
                position=[1.5, 1.5, 0.5],
                color_rgba=[0.5, 0, 0, 1],
            )
        )
        print(
            "Added missing target_object_id "{task.target_object_id}' to task objects."
        )
    if (
        task.reference_object_id not in obj_ids_in_task
        and task.reference_object_id != task.target_object_id
    ):
        task.initial_objects.append(
            ObjectState(
                id=task.reference_object_id,
                type="sphere",
                position=[-1.5, 1.5, 0.5],
                color_rgba=[0, 0, 0.5, 1],
            )
        )
        print(
            "Added missing reference_object_id "{task.reference_object_id}' to task objects."
        )
    return task


# --- API Endpoints ---
@app.post(
    "/environments/setup", response_model=EnvironmentInfoResponse, status_code=201
)
async def setup_new_environment_api(request: SetupEnvironmentRequest):
    env_id = f"padres_env_{uuid.uuid4().hex[:8]}"
    padres_env_instance = (
        SpatialEnvironmentMVP()
    )  # Create a new instance for this environment

    try:
        # Construct SpatialTask based on request and predefined templates/defaults
        task_to_run = get_task_definition(
            request.task_name, request.initial_objects, request.task_parameters
        )
        task_to_run.task_id = (
            f"{request.task_name}_{env_id}"  # Ensure env_id uniqueness in task_id
        )

        await padres_env_instance.initialize_task(task_to_run)

        if padres_env_instance.current_task is None:
            raise RuntimeError(
                "Environment did not set current_task after initialize_task call."
            )

        llm_prompt = padres_env_instance._create_llm_prompt(
            padres_env_instance.current_task,
            padres_env_instance.current_task.initial_objects,
        )
        initial_state_viz = (
            padres_env_instance.simulator.get_current_state_for_visualization()
        )

        active_environments[env_id] = padres_env_instance  # Store the instance

        return EnvironmentInfoResponse(
            environment_id=env_id,
            task_id=padres_env_instance.current_task.task_id,
            llm_prompt=llm_prompt,
            initial_state_viz=initial_state_viz,
            message="Environment for task "{request.task_name}' (Specific ID: {padres_env_instance.current_task.task_id}) initialized.",
        )
    except Exception as e:
        print(
            "Error during environment setup for task "{request.task_name}' (env_id: {env_id}): {type(e).__name__} - {e}"
        )
        if (
            padres_env_instance.simulator
            and padres_env_instance.simulator.client_id != -1
        ):
            padres_env_instance.simulator.cleanup()
        if env_id in active_environments:
            del active_environments[env_id]
        raise HTTPException(
            status_code=500, detail=f"Failed to setup environment: {str(e)}"
        )


@app.post("/environments/{environment_id}/action", response_model=ActionResultResponse)
async def execute_environment_action_api(
    environment_id: str, request: ExecuteActionRequest
):
    if environment_id not in active_environments:
        raise HTTPException(
            status_code=404,
            detail="Environment ID "{environment_id}' not found or not active.",
        )

    padres_env_instance = active_environments[environment_id]

    if not padres_env_instance.current_task:
        raise HTTPException(
            status_code=409,
            detail="Environment "{environment_id}' has no active task. Please setup first.",
        )

    parsed_action_for_env = {
        "action_type": request.action_name,
        **request.action_parameters,
    }
    if (
        request.action_name == "move_object"
        and "object_id" not in parsed_action_for_env
    ):
        parsed_action_for_env["object_id"] = (
            padres_env_instance.current_task.target_object_id
        )

    try:
        outcome = await padres_env_instance.apply_action_and_get_outcome(
            parsed_action_for_env
        )

        if isinstance(outcome, dict) and outcome.get("error"):
            print(
                "Error from apply_action_and_get_outcome for env "{environment_id}': {outcome}"
            )
            # Pass through more specific error if available from outcome
            error_message = outcome.get(
                "error", "Unknown error during action execution."
            )
            error_details = outcome.get("details", "")
            status_code = outcome.get(
                "status_code", 500
            )  # If service itself determined an HTTP-like code
            if not isinstance(status_code, int) or not (400 <= status_code < 600):
                status_code = 500
            raise HTTPException(
                status_code=status_code, detail=f"{error_message} - {error_details}"
            )

        return ActionResultResponse(
            environment_id=environment_id,
            new_state_viz=outcome["new_state_viz"],
            reward=outcome["reward"],
            done=outcome["done"],
            observation=outcome.get("observation"),
            message=outcome.get("message", "Action processed."),
        )
    except HTTPException:
        raise
    except Exception as e:
        print(
            "Error during action execution for environment "{environment_id}': {type(e).__name__} - {e}"
        )
        import traceback

        traceback.print_exc()
        raise HTTPException(
            status_code=500, detail=f"Failed to execute action: {str(e)}"
        )


@app.delete("/environments/{environment_id}", status_code=204)
async def cleanup_environment_api(environment_id: str):
    padres_env_instance = active_environments.pop(environment_id, None)
    if padres_env_instance:
        if hasattr(padres_env_instance, "simulator") and padres_env_instance.simulator:
            padres_env_instance.simulator.cleanup()
        print(
            "Environment "{environment_id}' cleaned up and removed from active list via API call."
        )
    else:
        print(
            "Cleanup requested for env "{environment_id}', but it was not found (already cleaned up or never existed)."
        )
    return


@app.on_event("shutdown")
async def app_shutdown():
    print("FastAPI application shutdown: Cleaning up active Padres environments...")
    env_ids_to_cleanup = list(active_environments.keys())
    for env_id in env_ids_to_cleanup:  # Iterate over a copy of keys for safe removal
        padres_env_instance = active_environments.pop(env_id, None)
        if padres_env_instance:
            print(f"  Cleaning up environment: {env_id}")
            if (
                hasattr(padres_env_instance, "simulator")
                and padres_env_instance.simulator
            ):
                padres_env_instance.simulator.cleanup()
    print("All active Padres environments cleaned up.")


# Example of how to run this service (e.g., using uvicorn)
# uvicorn spatial_rl_mvp.padres_service_api:app --reload --port 8001 --host 0.0.0.0
# (Assuming this file is saved as padres_service_api.py inside spatial_rl_mvp folder)
